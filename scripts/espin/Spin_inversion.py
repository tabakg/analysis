"""Created on Thu Jul 18th 2013Script to test Square and Gaussian envelope shapes of pulses on the inversion characteristics on a 2 level, S = 1, quantum system for quantum teleportation protocolsKleine handleiding:Je kan steeds een pulse shape simuleren door aan de onderkant een bepaalde 'execute' functie aan te roepen. In deze functie kan je zelf de maximum rabi frequency of een bepaalde pulse time aangeven om zo een pi-pulse te maken. Je kan ook gebruik maken van de thresholdfunctie, die probeert dan een zo hoog mogelijke rabi frequentie te vinden terwijl de N0 transitie maar met een bepaalde waarde gegeven door threshold wordt geflipt (werkt nu alleen nog goed als de driving frequency lager is dan de threshold frequency, dus bij bijvoorbeeld Nm1 resonant en N0 detuned. Als je op N0 drived moet je een aantal minnetjes en plusjes her en der veranderen).Helemaal bovenin staan nog een paar systeem constantes die je ook eventueel kan aanpassen, zoals het aantal simulatiepunten en de driving frequency.@author: Tom Timmerman, Quantum Transport TU Delft. Based on code written by Wolfgang Pfaff, Quantum Transport TU Delft """from numpy import *from matplotlib.pyplot import *#from qutip import *from scipy.optimize import minimizeimport pprintimport sysclose("all")"""---------------------System constants----------------------------- """D = 2*pi*2.878e9                # Energy splitting between |00 > and | 10 > electron spin statesgamma_e = 2*pi*2.802e10         # gyromagnetic ratio for electrongamma_N = 2*pi*3.077e6          # gyromagnetic ratio for nitrogen nucleusBz = 1.75e-3                       # Applied static magnetic field for inducing Zeeman splittingAN = 2*pi*2.189e6               # Splitting between mi = -1, mi = 0 and mi = 0, mi = +1, or for qubit | 10> and |11>A = AN + gamma_N*Bz             # Splitting taking into account Nuclear Zeeman splittingT2 = 1e-6                       # dephasing time of systemsigma = 2*pi*(T2*pi*sqrt(2))**-1# Standard deviation of spin energy value due to lattice vibrations etch_bar = 1                       # h_bar normalised to Q = 2*pi*4.95e6                      # nuclear quadrupolar splittingNm1 = D - gamma_e * Bz - A      # Energy transition of ms = -1, mi = -1 to ms = 0, mi = -1N0 = D - gamma_e * Bz           # Energy transition of ms = -1, mi = 0 to ms = 0, mi =0Np1 = D - gamma_e * Bz + A      # Energy transition of ms = -1, mi = +1 to ms = 0, mi = +1""""-------------------Pulse Constants-------------------------------"""pts_prob = 201pts_pop = 101pts_line = 501w0_array=linspace(Nm1-2*pi*5e6,Np1+2*pi*5e6, pts_prob)   # totalfrequency domain to be examined                          wd = Nm1                                            # driving radiansw1 = A/sqrt(3)                                      # Rabi radians for pi2pi square pulsephi = 0                                             # initial phase"""------------------ Pulse Generation --------------- -------------"""def Square_Pulse(t,args):    "Compute Square Pulse envelope shape for Hamiltonian"        A = args['A']    Single_Amp_Square = A*1        return Single_Amp_Square # only one value and no array as mesolve function requires specific t dependent function outputdef Gaussian_Pulse(t,args):    " Compute Gaussian pulse envelope shape for Hamiltonian, multiple Gauss shapes are possible "        A = args['A']    mu = args['mu']    std = args['std']    Amp_Gauss = A*exp(-(((t-mu)**2)/(2*std**2)))    #Amp_Gauss = A[0]*exp(-(((t-mu[0])**2)/(2*std[0]**2)))+  \    #A[1]*exp(-(((t-mu[1])**2)/(2*std[1]**2)))+A[2]*exp(-(((t-mu[2])**2)/(2*std[2]**2)))         return Amp_Gaussdef Hermite_Pulse(t,args):    "Compute Hermite 180 envelope pulseshape. Coefficients from W.Warren's paper"    A = args['A']    mu = args['mu']    T = args['T']    Amp_Hermite = A*(1-0.956*((t-mu)/T)**2)*exp(-((t-mu)/T)**2)    return Amp_Hermitedef Reburp_Pulse(t,args):    "Compute Reburp 180 evenlope pulseshape. \    Coeffecients from Geen and Freeman. Pulseshape specifically designed to have flat inversion probability"        F_0 = 0.49    F_coeff = [0.49,-1.02,1.11,-1.57,0.83,-0.42,0.26,-0.16,+0.10,-0.07,+0.04,-0.03,+0.01,-0.02,0,0.01]    A = args['A']    T = args['T_burp']    F_coeff[:] = [x*A for x in F_coeff]    Amp_Reburp_list=zeros(len(F_coeff))        for i,c in enumerate(F_coeff):          Amp_Reburp_list[i] = c*cos(i*((2*pi)/T)*t)    Amp_Reburp= sum(Amp_Reburp_list)    return Amp_Reburpdef Plot_Square_Pulse(t,args,pts = pts_line):    "Plots Square Pulse"        A = args['A']    t_square = linspace(0,t,pts)    Amp_Square = A*ones(pts)        figure()    plot(t_square,Amp_Square)    ylabel('Rabi frequency (radians, s^-1)')    xlabel('time(s))')    title('Microwave square envelope pulse')    return t_square, Amp_Squaredef Plot_Gaussian_Pulse(t,args, pts = pts_line):    "Plots Gaussian Pulse"        t_gauss = linspace(0,t,pts)    A = args['A']    mu = args['mu']    std = args['std']        Amp_Gauss = A*exp(-(((t_gauss-mu)**2)/(2*std**2)))        #Amp_Gauss = A[0]*exp(-(((t_gauss-mu[0])**2)/(2*std[0]**2)))+  \    #A[1]*exp(-(((t_gauss-mu[1])**2)/(2*std[1]**2)))+A[2]*exp(-(((t_gauss-mu[2])**2)/(2*std[2]**2))) # Gaussian envelope, not normalised        figure()    plot(t_gauss, Amp_Gauss)    ylabel('Rabi frequency (radians, s^-1)')    xlabel('time(s)')    title('Microwave Gaussian envelope pulse')    return t_gauss, Amp_Gaussdef Plot_Hermite_Pulse(t,args, pts = pts_line):    "Plots Hermite Pulse"        t_hermite = linspace(0,t,pts)    A = args['A']    mu = args['mu']    T = args['T']           Amp_Hermite = A*(1-0.956*((t_hermite-mu)/T)**2)*exp(-((t_hermite-mu)/T)**2)        figure()    plot(t_hermite,Amp_Hermite)    ylabel('Rabi frequency (radians, s^-1)')    xlabel('time(s)')    #axis([0,t,None,None])    title('Microwave Hermite 180 envelope pulse')    return t_hermite, Amp_Hermitedef Plot_Reburp_Pulse(t,args, pts = 256):    "Plots Hermite Pulse. Coefficients from Geen and Freeman, based on optimization procedure of 256 data points"        t_reburp = linspace( 0,t,pts)    F_0 = 0.49    F_coeff = [0.49,-1.02,1.11,-1.57,0.83,-0.42,0.26,-0.16,+0.10,-0.07,+0.04,-0.03,+0.01,-0.02,0,0.01] # Fourier series coefficients for Np = 256, taken from Geen and Freeman paper    A = args['A']    T = args['T_burp']    F_coeff[:] = [x*A for x in F_coeff]    Amp_Reburp_list=zeros((pts,len(F_coeff)))    Amp_Reburp = zeros((pts))        for j in range(pts):        for i,c in enumerate(F_coeff):              Amp_Reburp_list[j,i] = c*cos(i*((2*pi)/T)*t_reburp[j])        Amp_Reburp[j]= (sum(Amp_Reburp_list[j]))        figure()    plot(t_reburp,Amp_Reburp)    ylabel('Rabi frequency (radians, s^-1)')    xlabel('time(s)')    #axis([0,,None,None])    title('Microwave Reburp 180 envelope pulse')    return t_reburp, Amp_Reburpdef Pulse_Integral(plotfunction, *args, **kw):    """ Computes integral of pulse envelope"""        t_values, amp_values = plotfunction(*args, **kw)    integral =trapz(amp_values,t_values)    print "integral = ", plotfunction , integral    return integraldef Find_pi_pulsetime(plotfunction,amplitude):    "determine the duration of a pi pulse on resonance by optimization for a Plotfunction with given amplitude. Gaussian automatically centered"    """Initialisation conditions"""        t_init = 0.5*2*pi/amplitude               def func(x):        absolute = abs(Pulse_Integral(plotfunction,x,{'A': amplitude, 'mu': 0.5*x,'std': 1./6*x,'T':1./6*x,'T_burp': x})\        -pi) # - pi because total integral for pi pulse should be equal to pi         #print "absolute =", absolute        return absolute        res = minimize(func, t_init, method='Nelder-Mead')    close("all")    print res    return res.x[0]def Find_pi_amplitude(plotfunction,pulsetime):    "determine the amplitude of a pulse on resonance by optimization for a Plotfunction with given pulsetime. Gaussian automatically centered"    """Initialisation conditions"""        pulsetime = pulsetime          amp_init = w1    if plotfunction == Plot_Reburp_Pulse:        def func(x):            absolute = abs(Pulse_Integral(plotfunction,pulsetime,{'A': x/6.114, 'mu': 0.5*pulsetime,'std': 1./6*pulsetime,'T':1./6*pulsetime,'T_burp': pulsetime})\            -pi) # - pi because total integral for pi pulse should be equal to pi             #print "absolute =", absolute            return absolute    else:        def func(x):            absolute = abs(Pulse_Integral(plotfunction,pulsetime,{'A': x, 'mu': 0.5*pulsetime,'std': 1./6*pulsetime,'T':1./6*pulsetime,'T_burp': pulsetime})\            -pi) # - pi because total integral for pi pulse should be equal to pi             #print "absolute =", absolute            return absolute        res = minimize(func, amp_init, method='Nelder-Mead')    close("all")    print res    if plotfunction == Plot_Reburp_Pulse:        result = res.x[0]/6.114    else:        result = res.x[0]            return result"""--------------------General Inversion formulas----------------------------"""#16a(y)def Xvals(wvals):    "Helper function: Transforms radians values into frequencies and with respect to Nm1."        return (wvals - Nm1)/2/pi * 1e-6def Lineshape(wvals, omega0, sigma=sigma, *args, **kw):    "computes the different possibilities of the quantum states of the system, normalised to 1"        line = 1/(sigma*sqrt(2*pi)) * exp(-((wvals-omega0)**2)/(2*sigma**2))        return linedef Inversionprob(w0,wd,pulsefunction,t,args,phi=0,**kw):    """    Computes several parameters. First: It states Time independent Hamiltonian and Time dependent coefficient w1 using different pulse shapes.     The pulse envelope amplitude determines the Rabi Frequency        H0 = Time independent part    H1,2 = Time dependent part    w1 = Rabi frequency (actually radians), which is the inverse duration of one rotation of the spin.    Rabi frequency is directly related to the amplitude of the pulse        w0 = transition frequency of quantum state (will be made into an array later)    wd = driving frequency, which will always be the expectation value of the state to be inverted        NB. For a pi2pi spin, the Rabifrequency should be w1 = detuning/sqrt(3)     t = duration of the pulse. For a pi-flip, the duration needs to one half of a rabi frequency    Funtion computes inversion probability of quantum state at certain energy and with a certain time dependent H when a pulse is applied.            psi0 = initial state |10 > equals ms = -1, mi = -1    tpts = number of timepoints to be taken into account for solver    mesolve calculates unitary evolution according to schrodinger's equation.    It requires H, an inital sate, a number of points to evaluate at, and which operator to evaluate    output of the function is the expectation value of operator at index [0] (Sz operator) at index [-1] (time t)        Check QuTiP manual on specific input format for timedependent Hamiltonian    H = Hamiltonian in rotating frame and with rotating wave approximation and timedependent    """    tpts = kw.pop('tpts',10)       H0 = -(w0 - wd) * sigmaz()/2.    H1 = -(cos(phi) * sigmax()/2. + sin(phi) * sigmay()/2.)    H = [H0,[H1,pulsefunction]]       #print H     psi0 = basis(2,0)    result = mesolve(H, psi0, linspace(0,t,tpts), [], [sigmaz()], args=args)    #print result.expect    expect = - result.expect[0][-1] / 2. + 0.5    return expect.realdef Inversion_w0(w0_array,*args,**kw):    "Sweeps over values of w0_array and computes for every point the inversionprob of that point"        invprobs = []        print "\n"'evaluating %d frequencies...:' % len(w0_array)    for i,w0 in enumerate(w0_array):        print '%d,' % (i+1),        invprobs.append(Inversionprob(w0, *args, **kw))        return invprobsdef Inversionpop(w0_array,qstate,invp):    """Compute total inverted population through multiplying the inversion probability with the probability of the    quantum state and taking the integral over a range of w0_array"""        invpop = trapz(qstate*invp, w0_array)       return invpop"""----------------------------defining quantum states lineshapes -------------------"""def Lineshape_Nm1(pts=pts_pop, sigma=sigma, wvals=2*pi*2e6):    wvals_m1 = Nm1+linspace(-wvals, wvals, pts)    line_m1 = Lineshape(wvals_m1, Nm1, sigma=sigma)        return wvals_m1, line_m1def Lineshape_N0(pts=pts_pop, sigma=sigma, wvals=2*pi*2e6):    wvals_0 = N0+linspace(-wvals, wvals, pts)    line_0 = Lineshape(wvals_0, N0, sigma=sigma)        return wvals_0, line_0def Lineshape_Np1(pts=pts_pop, sigma=sigma, wvals=2*pi*2e6):    wvals_p1 = Np1+linspace(-wvals, wvals, pts)    line_p1 = Lineshape(wvals_p1, Np1, sigma=sigma)        return wvals_p1, line_p1"""--------------------Calculating inversions for system-------------------------"""def Plot_inversion_probability(w0_array,t,invp):    "Plot population of quantum states and inversion probability"       wvals_m1, line_m1 = Lineshape_Nm1()    wvals_0, line_0 = Lineshape_N0()    wvals_p1, line_p1 = Lineshape_Np1()    fig = figure()    ax = fig.add_subplot(111)    ax.plot(Xvals(wvals_m1), line_m1, 'b-')    ax.plot(Xvals(wvals_0), line_0, 'r-')    ax.plot(Xvals(wvals_p1), line_p1, 'g-')    ax.set_xlabel('Detuning (MHz)')    ax.set_ylabel('Population density')    ax.yaxis.tick_left()    ax2 = fig.add_subplot(111, sharex=ax, frameon=False)    ax2.yaxis.tick_right()    ax2.yaxis.set_label_position("right")    ax2.plot(Xvals(w0_array), invp, 'k--', lw=2)    ax2.axis([None,None,0,1])    ax2.set_ylabel('Inversion probability')    ax2.set_title("Inversion probability and spin states ms = -1, mi = -1, mi = 0 and mi = +1")    returndef Sigma_inversion_probability(pulsefunction,t,args, pts = pts_pop):    "Plots probability of inversion vs sigma, the standard deviation of the quantum spin state at the resonance frequency"        T2 = linspace(0.1e-6,3e-6,51)    sigma_array= 2*pi*(T2*pi*sqrt(2))**-1        wvals_m1, none = Lineshape_Nm1(pts)    invprob_m1 = Inversion_w0(wvals_m1,wd,pulsefunction,t,args)    sigma_inversion = []    for s in sigma_array:        line = Lineshape(wvals_m1, wd, s)        sigma_inversion.append(Inversionpop(wvals_m1, line, invprob_m1))    xvals = sigma_array/2/pi * 1e-3 # back to kHz freq. domain    invfig = figure()    ax = invfig.add_subplot(111)    ax.plot(T2*1e6, sigma_inversion, 'ko:')    ax.set_xlabel('Decoherence (us)')    ax.set_ylabel('Inversion probability')    ax.set_xlim(0,None)    returndef Sigma_inversion_population(pulsefunction,plotfunction,t,args,wd = wd, pts = pts_prob):    """Plots population of inversion vs sigma, the standard deviation of the quantum spin state at the driving frequency.    Standard set to driving frequency = Nm1"""        T2 = linspace(0.1e-6,3e-6,51)    sigma_array= 2*pi*(T2*pi*sqrt(2))**-1 #different decoherence times of NV center sample    wvals = 3*np.max(sigma_array)         ip_sigmavals_Nm1 = zeros((len(sigma_array)))    ip_sigmavals_N0 = zeros((len(sigma_array)))    ip_sigmavals_Np1 = zeros((len(sigma_array)))    result = {}    result['sigma'] = sigma_array    wvals_Nm1,a  = Lineshape_Nm1(pts,1,wvals)    wvals_N0,a   = Lineshape_N0(pts,1,wvals)    wvals_Np1,a  = Lineshape_Np1(pts,1,wvals)            #invprob_Nm1 = Inversion_w0(wvals_Nm1, wd, pulsefunction, t,args)    #invprob_N0 = Inversion_w0(wvals_N0, wd, pulsefunction, t,args)    #invprob_Np1 = Inversion_w0(wvals_Np1, wd, pulsefunction, t,args)    for i,s in enumerate(sigma_array):        #Amp,t =Rabifrequency_threshold(pulsefunction,plotfunction,low_thresh_value = 0.001,thresh_freq = N0,w0 = Nm1, sigma =  s)                                   invprob_Nm1 = Inversion_w0(wvals_Nm1, wd, pulsefunction, t,args)        invprob_N0 = Inversion_w0(wvals_N0, wd, pulsefunction, t,args)        #invprob_Np1 = Inversion_w0(wvals_Np1, wd, pulsefunction, t,args)        b,line_Nm1 = Lineshape_Nm1(pts,s,wvals)        ip_sigmavals_Nm1[i] = Inversionpop(wvals_Nm1,line_Nm1,invprob_Nm1)                b,line_N0 = Lineshape_N0(pts,s,wvals)        ip_sigmavals_N0[i] = Inversionpop(wvals_N0,line_N0,invprob_N0)                 #b,line_Np1 = Lineshape_Np1(pts,s,wvals)        #ip_sigmavals_Np1[i] = Inversionpop(wvals_Np1,line_Np1,invprob_Np1)            fig, ax = subplots(1,1)    ax.plot(T2*1e6, ip_sigmavals_Nm1, 'bo--', label='m_I=-1')    ax.plot(T2*1e6, ip_sigmavals_N0, 'ro--', label='m_I=0')    #ax.plot(T2*1e6, ip_sigmavals_Np1, 'go--', label='m_I=+1')    legend(loc='best')      ax.set_ylim(0,1.1)    ax.set_xlabel('Decoherence time (us)')    ax.set_ylabel('Inversion population')    ax.set_title('Inversion population of spin state vs. decoherence time for Rabifrequency %.3f MHz' %(A/(2*pi*1e6)))    return def Inversionpopulation(pulsefunction,t,args, pts = pts_pop):    "Calculates which fraction of quantum state will be inverted with specific pulse applied"        wvals_m1, line_m1 = Lineshape_Nm1(pts)    wvals_0, line_0 = Lineshape_N0(pts)    wvals_p1, line_p1 = Lineshape_Np1(pts)    invprob_m1 = Inversion_w0(wvals_m1,wd,pulsefunction,t,args)    invprob_0 = Inversion_w0(wvals_0,wd,pulsefunction,t,args)    invprob_p1 = Inversion_w0(wvals_p1,wd,pulsefunction,t,args)    invpop_m1 = Inversionpop(wvals_m1, line_m1, invprob_m1)    invpop_0 = Inversionpop(wvals_0, line_0, invprob_0)    invpop_p1 = Inversionpop(wvals_p1, line_p1,invprob_p1)    print "\n" "Inversion population Nm1 =" ,invpop_m1.real     print "Inversion population N0 ="  ,invpop_0.real    print "Inversion population Np1 =" ,invpop_p1.real        return invprob_m1,invprob_0,invprob_p1,invpop_m1.real, invpop_0.real, invpop_p1.realdef Plot_inversion_population(invprob_m1,invprob_0,invprob_p1,pulsefunction,t,args, pts = pts_pop):    "Plots the total inverted population vs transition frequency, using inversion probabilities computed in Inversionpopulation()"    wvals_m1, line_m1 = Lineshape_Nm1(pts)    wvals_0, line_0 = Lineshape_N0(pts)    wvals_p1, line_p1 = Lineshape_Np1(pts)       inversionpop_vs_w0_m1 = line_m1*invprob_m1/np.max(line_m1)    inversionpop_vs_w0_0 = line_m1*invprob_0/np.max(line_0)    inversionpop_vs_w0_p1 = line_m1*invprob_p1/np.max(line_p1)    fig = figure()    ax = fig.add_subplot(111)    ax.plot(Xvals(wvals_m1), inversionpop_vs_w0_m1, 'b-')    ax.plot(Xvals(wvals_0), inversionpop_vs_w0_0, 'r-')    ax.plot(Xvals(wvals_p1), inversionpop_vs_w0_p1, 'g-')    ax.set_xlabel('Detuning (MHz)')    ax.set_ylabel('Inverted Population density')    ax.set_title("Total inverted population density of quantum spin states normalised with respect to original population")    ax.set_ylim(0,1)    return def Rabifrequency_probability(pulsefunction,plotfunction,pts = pts_pop,wd= wd,**kw):    """computes inversion probability of three quantum states, mi = -1,0,1 and a range of applied Rabi frequencies.    All pulsetimes are of course chosen to perform a pi-flip at the driving frequency, which is Nm1. The result is saved in a .nfz file"""    wvals_Nm1,line_Nm1 = Lineshape_Nm1(pts)    wvals_N0,line_N0   = Lineshape_N0(pts)    wvals_Np1,line_Np1 = Lineshape_Np1(pts)    b = range(-4,6)    w1_range = ([0.1e6,0.3e6,0.5e6,0.8e6,1e6,1.3e6,1.5e6,2e6,2e6,3e6,5e6])                             if pulsefunction == Reburp_Pulse:        w1_vals =  [x*((2*pi)*6.1137) for x in w1_range]    else:         w1_vals =  [x*(2*pi) for x in w1_range]     t_vals = []    for i in range(0,len(w1_vals)):        t_vals.append(Find_pi_pulsetime(plotfunction,w1_vals[i]))         result = {}    result['wvals_Nm1'] = wvals_Nm1    result['wvals_N0'] = wvals_N0    result['wvals_Np1'] = wvals_Np1    result['w1vals'] = w1_vals    result['tvals'] = t_vals        ipvals_Nm1 = zeros((pts, len(w1_vals)))    ipvals_N0 = zeros((pts, len(w1_vals)))    ipvals_Np1 = zeros((pts, len(w1_vals)))    mu = [x*0.5 for x in t_vals]    std =[1./6*x for x in t_vals]    T = [1./6*x for x in t_vals]    T_burp = t_vals    for i in range(0,len(w1_vals)):                args = {'A': w1_vals[i],'mu': mu[i],'std': std[i],'T': T[i],'T_burp': T_burp[i]}        print "\n"'inversion for mI=-1, at driving pt %d / %d...' % (i+1, len(w1_vals))          ipvals_Nm1[:,i] = Inversion_w0(wvals_Nm1, wd, pulsefunction, t_vals[i],args)        print               print "\n" 'inversion for mI=0, at driving pt %d / %d...' % (i+1, len(w1_vals))        ipvals_N0[:,i] = Inversion_w0(wvals_N0, wd, pulsefunction, t_vals[i],args)        print        print "\n" 'inversion for mI=+1, at driving pt %d / %d...' % (i+1, len(w1_vals))          ipvals_Np1[:,i] = Inversion_w0(wvals_Np1, wd, pulsefunction, t_vals[i],args)        print    result['inversionprob_Nm1'] = ipvals_Nm1    result['inversionprob_N0'] = ipvals_N0    result['inversionprob_Np1'] = ipvals_Np1    filename = 'Inversion_probabilities_'+pulsefunction.__name__    savez(filename, **result) # make filename unique via pulsefunction and date or something    return def Plot_Rabifrequency_probability(pulsefunction,plotfunction):    "Examines results of Rabifrequency function, and plots inversion population vs applied Rabifrequency"    fn='Inversion_probabilities_'+pulsefunction.__name__+'.npz'    f = np.load(fn)    wvals_Nm1 = f['wvals_Nm1']    wvals_N0 = f['wvals_N0']    wvals_Np1 = f['wvals_Np1']    ipvals_N0 = f['inversionprob_N0']    ipvals_Nm1 = f['inversionprob_Nm1']    ipvals_Np1 = f['inversionprob_Np1']    w1_vals = f['w1vals']    w1_vals = w1_vals*6.1137        f.close()        _w1, line_m1 = Lineshape_Nm1()    _w0, line_0 = Lineshape_N0()    _wp1, line_p1 = Lineshape_Np1()    invpop0 = []    invpopm1 = []    invpopp1 = []    for i,w1 in enumerate(w1_vals):        invpopm1.append(Inversionpop(wvals_Nm1, line_m1, ipvals_Nm1[:,i]))        invpop0.append(Inversionpop(wvals_N0, line_0, ipvals_N0[:,i]))        invpopp1.append(Inversionpop(wvals_Np1, line_p1, ipvals_Np1[:,i]))        ax2_loc = linspace(min(w1_vals/(2*pi*1e6)),max(w1_vals/(2*pi*1e6))+1,6)    t_pw = []    for i in range(len(ax2_loc)):        t_pw.append(Find_pi_pulsetime(plotfunction,ax2_loc[i]*2*pi*1e6))    t_pw = ['%.2g' % x for x in t_pw]          fig, ax = subplots(1,1)    ax2=ax.twiny()    ax.set_ylim(-0.05,1.1)    ax.set_xlim(0,max(w1_vals/(2*pi*1e6)+1))    ax.set_xlabel('Rabi frequency (MHz)')    ax.set_ylabel('Inversion population')    ax2.set_xticks(ax2_loc)    ax2.set_xticklabels(t_pw)    ax2.set_xlabel('Pulse duration (s)')    ax.plot(w1_vals/2/pi*1e-6, invpopm1, 'bo--', label='m_I=-1')    ax.plot(w1_vals/2/pi*1e-6, invpop0, 'ro--', label='m_I=0')    ax.plot(w1_vals/2/pi*1e-6, invpopp1, 'go--', label='m_I=+1')    legend(loc='best')    for x, y1, y2, y3 in zip(w1_vals, invpopm1, invpop0, invpopp1):        ax.annotate('{:.1f}'.format(y1*100), xy=(x/2/pi*1e-6,y1), xytext=(-5,5),            textcoords='offset points')        ax.annotate('{:.1f}'.format(y2*100), (x/2/pi*1e-6,y2), xytext=(-5,5),            textcoords='offset points')        ax.annotate('{:.1f}'.format(y3*100), (x/2/pi*1e-6,y3), xytext=(-5,5),            textcoords='offset points')    plt.text(0.5, 1.08, 'Inversion population of spin state vs. applied Rabifrequency/Pulse time',        horizontalalignment = 'center',        fontsize=20,        transform = ax2.transAxes)def Rabifrequency_threshold(pulsefunction,plotfunction,low_thresh_value = 0.01,thresh_freq = N0,w0 = Nm1, sigma = sigma):    "Finds the highest Rabifrequency for which the inversion probability does not exceed \    the thresh_value at thresh_freq-sigma"    min_Rabi = 0.1e6    max_Rabi = abs((thresh_freq-w0)/(2*pi))    step = 21    if pulsefunction == Reburp_Pulse:        amp_array = linspace(2*pi*max_Rabi,2*pi*min_Rabi,step)/6.1137    else:         amp_array = linspace(2*pi*max_Rabi,2*pi*min_Rabi,step)         step = amp_array[0]-amp_array[1]    invprob=  1    invprob_w0 = 0.01    i = 0    while (invprob > low_thresh_value and i != len(amp_array)):                print "computing Rabi frequency for %.3f MHz, pt %d/%d" %(amp_array[i]/(2*pi*1e6),i+1,len(amp_array))                Amp  = amp_array[i]                                              t    = Find_pi_pulsetime(plotfunction,Amp)                     mu   = 0.5*t        std  = 1./6*t        T = 1./6*t        T_burp = t        args = {'A': Amp, 'mu': mu,'std': std,'T':T,'T_burp': T_burp}        invprob = Inversionprob(thresh_freq-sigma,wd,pulsefunction,t,args) # this line sometimes need adjusting, changing sign!        print "invprob = ",invprob        rabi = amp_array[i]        i = i+1       if i == len(amp_array):        print "No matching Rabi frequency found for set conditions. Try to change the range of rabifrequencies to be evaluated,\        decrease the interval step in your original search range or adjust your threshold"        sys.exit()        smallsweep = 0    else:          print "Found rough estimate, starting smallsweeping Rabifrequency"        smallsweep = 1            if smallsweep == 1:        amp_array = rabi +linspace(step,-step,11)                invprob = 1        invprob_w0 = 0.01                i = 0                while (invprob > low_thresh_value):                        print "computing small_sweep Rabi frequency for %.3f MHz, pt %d/%d" %(amp_array[i]/(2*pi*1e6),i+1,len(amp_array))            Amp  = amp_array[i]                                                  t    = Find_pi_pulsetime(plotfunction,Amp)                         mu   = 0.5*t            std  = 1./6*t            T = 1./6*t            T_burp = t            args = {'A': Amp, 'mu': mu,'std': std,'T':T,'T_burp': T_burp}            invprob = Inversionprob(thresh_freq-sigma,wd,pulsefunction,t,args)            invprob_w0 = Inversionprob(w0+sigma,wd,pulsefunction,t,args)            print "inversion probability threshold -1sigma frequency = ", invprob            print "inversion probability at resonance + 1sigma frequency =", invprob_w0                                i = i+1        print "\n""Rabifrequency = %.3f MHz""\n" % ((amp_array[i-1])/(2*pi*1e6))             else:        None    return amp_array[i-1],t        """ -----------------------Executing section--------------------------------------"""def Execute_Gauss():    "Exectues a Gaussian Pulse on system"        pulsefunction = Gaussian_Pulse    plotfunction  = Plot_Gaussian_Pulse        #Amp,t  = Rabifrequency_threshold(pulsefunction,plotfunction,0.01)    # max Amplitude of Gaussian, max Rabi frequency. Function makes use of threshold for inversion performances.                                                                 Amp = 2*pi*0.8e6    t = Find_pi_pulsetime(plotfunction,Amp)    #t = 50e-9    #Amp = Find_pi_amplitude(plotfunction,t)    mu   = 0.5*t    std  = 1./6*t    args = {'A': Amp, 'mu': mu,'std': std}    print "Max Amplitude =" ,Amp/(2*pi*1e6)    print "pulsetime = ", t        Plot_Gaussian_Pulse(t,args)    Pulse_Integral(plotfunction,t,args)    invp = Inversion_w0(w0_array,wd,pulsefunction,t,args)    Plot_inversion_probability(w0_array,t,invp)    #Sigma_inversion_probability(pulsefunction,t,args)    #invprob_m1,invprob_0,invprob_p1,none,none,none = Inversionpopulation(pulsefunction,t,args)    #Plot_inversion_population(invprob_m1,invprob_0,invprob_p1,pulsefunction,t,args)        #Sigma_inversion_population(pulsefunction,plotfunction,t,args)    #Rabifrequency_probability(pulsefunction,plotfunction)    #Plot_Rabifrequency_probability(pulsefunction,plotfunction)    returndef Execute_Hermite():    "Executes a Hermite 180 Pulse on system"        pulsefunction = Hermite_Pulse    plotfunction  = Plot_Hermite_Pulse        #Amp,t  = Rabifrequency_threshold(pulsefunction,plotfunction,0.001)    # max Amplitude of Hermite, max Rabi frequency. Function makes use of threshold for inversion performances.                                                                 Amp = 2*pi*1.2e6    t = Find_pi_pulsetime(plotfunction,Amp)    #Amp = Find_pi_amplitude(plotfunction,t)        mu   = 0.5*t    T  = 1./6*t    args = {'A': Amp, 'mu': mu,'T': T}    print "Max Amplitude =" ,Amp/(2*pi*1e6)    print "pulsetime = ", t    #Plot_Hermite_Pulse(t,args)    #Pulse_Integral(plotfunction,t,args)    invp = Inversion_w0(w0_array,wd,pulsefunction,t,args)    Plot_inversion_probability(w0_array,t,invp)    #Sigma_inversion_probability(pulsefunction,t,args)    #invprob_m1,invprob_0,invprob_p1,none,none,none = Inversionpopulation(pulsefunction,t,args)    #Plot_inversion_population(invprob_m1,invprob_0,invprob_p1,pulsefunction,t,args)    #Sigma_inversion_population(pulsefunction,plotfunction,t,args)    #Rabifrequency_probability(pulsefunction,plotfunction)    #Plot_Rabifrequency_probability(pulsefunction,plotfunction)    returndef Execute_Reburp():    "Executes a Reburp 180 Pulse on system"        pulsefunction = Reburp_Pulse    plotfunction  = Plot_Reburp_Pulse        #Amp,t  = Rabifrequency_threshold(pulsefunction,plotfunction,0.0005)    Amp  = 2*pi*4e6/6.1137 #division by float to ensure Amp represents true max amplitude    t    = Find_pi_pulsetime(plotfunction,Amp)    #Amp = Find_pi_amplitude(plotfunction,t)    args = {'A': Amp,'T_burp':t}    print "Max Amplitude =" ,(6.1137*Amp)/(2*pi)    print "pulsetime = ", t    Plot_Reburp_Pulse(t,args)    Pulse_Integral(plotfunction,t,args)    invp = Inversion_w0(w0_array,wd,pulsefunction,t,args,tpts = 256)    Plot_inversion_probability(w0_array,t,invp)    #invprob_m1,invprob_0,invprob_p1,none,none,none = Inversionpopulation(pulsefunction,t,args)    #Plot_inversion_population(invprob_m1,invprob_0,invprob_p1,pulsefunction,t,args)    #Sigma_inversion_population(pulsefunction,plotfunction,t,args)    #Sigma_inversion_probability(pulsefunction,t,args)        #Rabifrequency_probability(pulsefunction,plotfunction)    #Plot_Rabifrequency_probability(pulsefunction,plotfunction)        return  def Execute_Square():    "Executes a Square Pulse on system"          pulsefunction = Square_Pulse    plotfunction  = Plot_Square_Pulse        #Amp,t  = Rabifrequency_threshold(pulsefunction,plotfunction,0.001)    Amp  = 2*pi*0.8e6    #Amp = Find_pi_amplitude(plotfunction,t)    t    = 0.5*2*pi/Amp    args = {'A': Amp}    print "Max Amplitude =" ,Amp/(2*pi*1e6)    print "pulsetime = ", t    #t = Find_pi_pulsetime(plotfunction,Amp)    #Plot_Square_Pulse(t,args)    #Pulse_Integral(plotfunction,t,args)    invp = Inversion_w0(w0_array,wd,pulsefunction,t,args)    Plot_inversion_probability(w0_array,t,invp)    #Sigma_inversion_probability(pulsefunction,t,args)    #invprob_m1,invprob_0,invprob_p1,none,none,none = Inversionpopulation(pulsefunction,t,args)    #Plot_inversion_population(invprob_m1,invprob_0,invprob_p1,pulsefunction,t,args)    #Sigma_inversion_population(pulsefunction,plotfunction,t,args)        #Rabifrequency_probability(pulsefunction,plotfunction)    #Plot_Rabifrequency_probability(pulsefunction,plotfunction)        return  """--------------------Input section------------------"""if __name__ == '__main__':     #Execute_Gauss()    Execute_Hermite()    #Execute_Reburp()    #Execute_Square()                         """                          To-Do:D:    Make Sigma_inversion_population work using Rabifrequency_threshold function to find optimum Rabifrequency    Generalise lineshapes of spin states into a multiplicity etc    """                                    